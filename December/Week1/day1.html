<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>day1</title>
    <style>
      /* .item {
            height: 50px;
            width: 100px;
            border: 1px solid red;
            display: inline-block;
        } */

      #ad {
        width: 200px;
        height: 200px;
        background-color: #bfa;
      }
    </style>
  </head>

  <body>
    <!-- <div class="container">
        <h2>点击切换颜色</h2>
        <div class="item"></div>
        <div class="item"></div>
        <div class="item"></div>
    </div> -->
    <div id="ad"></div>
    <script>
      
    </script>
    <script>
      // symbol
      // 内置值
      // class Person{
      //   static [Symbol.hasInstance](){
      //     console.log("我被用来声明对象了");
      //   }
      // }
      // let o = {}
      // console.log(o instanceof Person);

      // const arr = [1,2,3]
      // const arr1 = [4,5,6]
      // arr1[Symbol.isConcatSpreadable] = false
      // console.log(arr.concat(arr1)); // [1, 2, 3, Array(3)]

      // let s = Symbol();
      // console.log(s, typeof s); // 唯一性不可见

      // let s2 = Symbol("s2");
      // let s3 = Symbol("s2");
      // console.log(s2 === s3);

      // let s4 = Symbol.for("s2");
      // let s5 = Symbol.for("s2");
      // console.log(s4, typeof s4);
      // console.log(s4 === s5);
      // 不能与数据类型运算 比较

      // symbol向对象添加唯一的方法
      // let games = { up: () => {}, down: () => {} };
      // let methods = {
      //   up: Symbol(),
      //   down: Symbol(),
      // };
      // games[methods.up] = function () {
      //   console.log("up");
      // };
      // games[methods.down] = function () {
      //   console.log("down");
      // };
      // console.log(games);

      // let youxi = {
      //   name :"aaa",
      //   [Symbol('say')]: function(){
      //     console.log("say");
      //   },
      //   [Symbol('bao')]:function(){
      //     console.log("zibao");
      //   }
      // }
      // console.log(youxi);

      // USONB
      // u undefined
      // s string symbol
      // o object
      // n null number
      // b boolean bigint

      // 扩展运算符 ...
      // const a = ["a", "b", "c"];
      // const open = function(){
      //   console.log(arguments);
      // }

      // open(...a)

      // 数组的合并
      // const a = ['a', 'b']
      // const b = ['c','d']
      // console.log([...a, ...b]);

      // 数组的克隆,浅拷贝
      // const a = [1,2,3]
      // const b = [...a]
      // console.log(b);

      // 将伪数组转为真正的数组
      // let divs = document.querySelectorAll("div")
      // console.log([...divs]);

      // 函数参数默认值
      // 1. 形参初始值,参数放后边
      // function add(a, b, c = 10) {
      //   console.log(a + b + c);
      // }
      // add(1, 3, 3);

      // 与解构赋值联合使用
      // const test = ({a,b,c}) => {
      //   return a + b + c;
      // }

      // let res = test({a:1, b:2, c:4})
      // console.log(res);
      // 箭头函数 => 来定义函数

      // 点击div，2s后变成粉色
      // const turnPink = (e) => {
      //     return setTimeout(() => {
      //         return  e.target.style.background = "pink"
      //     }, 2000)
      // }

      // let ad = document.getElementById("ad");
      // ad.addEventListener("click", e => turnPink(e))

      // 从数组中返回偶数的元素
      // const arr = [1,6,9,100,25]
      // const res = arr.filter(d => d % 2 === 0)
      // console.log(res);
      // 适合与this无关的回调
      // 有关的，对象的this不适合

      // let fn = (a,b) => {
      //     console.log(a + b);
      // }
      // fn(1, 43)
      // 1.this是静态的，指向函数声明时的所在作用域下的this的值。
      // function getName(){
      //     console.log(this.name);
      // }
      // const getName1 = () => {
      //     console.log(this.name);
      // }

      // window.name = "window";
      // const school = {
      //     name : "school"
      // }

      // getName.call(school)
      // getName1.call(school)

      // getName.bind(school)()
      // getName1.bind(school)()

      // getName()
      // getName1()

      // 2.不能作为构造函数。
      // let Person = (name, age) => {
      //     this.name = name;
      //     this.age = age;
      // }

      // let p = new Person("aaa", 11) // 报错：Person is not a constructor

      // 3. 不能使用arguments
      // const test = () => {
      //     console.log(arguments); // arguments is not defined
      // }
      // test()

      // 4. 箭头函数的简写
      // 省略(),只有一个参数
      // const a = d => {
      //     console.log(d);
      // }
      // a(1)
      // 省略{},只有一条语句
      // const b = (n) => console.log(n * n);;
      // b(3)

      // 对象的简化写法
      // let name = "111";
      // let change = function(){
      //     console.log("test");
      // }

      // const obj = {
      //     name, change,
      //     funcImprove(){
      //         console.log("可直接添加函数");
      //     }
      // }
      // obj.funcImprove()
      // console.log(obj);
      // obj.change()

      /**
       * 模板字符串
       */
      // 声明
      // let str = `1111`;
      // console.log(str);

      // 内容可以直接出现换行符
      // let str = `<ul>111<ul>
      // `
      // 变量拼接
      // let lovelet = `魏晨`;
      // let out = `${lovelet}1111`;
      // console.log(out);

      /**
       * 解构赋值
       * */
      //1. 数组的解构赋值
      // const F4 = ["a", "bv", "cv", "dv"]
      // let [a,b,c,d] = F4;
      // console.log(b,c,d);
      //2. 对象的解构赋值
      // const zhao = {
      //     name:"赵本山",
      //     age:22,
      //     xiaopin: function(){
      //         console.log("我可以演小品");
      //     }
      // }

      // let {name, age1, xiaopin} = zhao;
      // console.log(name,age1);
      // xiaopin();

      /**
       * const
       * */

      // 定义常量
      // const school = "a";
      // console.log(school);

      // 1. 一定要赋初始值
      // const a; // Missing initializer in const declaration

      //2.一般常量使用大写
      // const A = "aaa";
      // 3.常量的值不能修改
      // const a = "111";
      // a = 1;//Assignment to constant variable.

      // 4.块级作用域
      // {
      //     const A = "AAAa";
      // }
      // console.log(A);// 报错：not defined
      // 5. 对数组or对象等元素进行修改，其不算是对常量的修改，不会报错。
      // const a = [1, 3, 3, 4];
      // a[3] = 1;
      // console.log(a);

      /**
       * let =====
       **/
      // let items = document.getElementsByClassName("item");
      // for(let i = 0; i < items.length; i+= 1){
      //     items[i].onclick = () => {
      //         // 修改当前的颜色
      //         items[i].style.background = "pink";
      //     }
      // }
      // 声明变量
      // let a;
      // let b, c, d;
      // let e = 100;
      // let f = 521, g = "abc", h = [];
      // 1. 变量不能重复声明
      // var可以，Identifier 'star' has already been declared
      // let star = "罗志祥";
      // let star = "小猪";

      // 2. 块级作用域 全局，函数，eval作用域
      // {
      //     let girl = "a";
      // }
      // console.log(girl);

      // 3. 不存在变量提升，
      // console.log(song);
      // var song = "aaa"; // undefined
      // let song = "aaa"; // Cannot access 'song' before initialization

      // 4. 不影响块级作用域链
      // {
      //     let school = "aaa";
      //     function fn(){
      //         console.log(school);
      //     }
      //     fn();
      // }
    </script>
  </body>
</html>
